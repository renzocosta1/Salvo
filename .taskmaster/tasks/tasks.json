{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Database Schema Expansion & Seed Data",
        "description": "Extend existing Supabase schema to support geographical hierarchy, new mission types, and the digital ballot system.",
        "details": "Execute SQL migrations to: 1. Add address and district columns (legislative_district, county, etc.) to 'profiles'. 2. Update 'profiles' role constraint to include national_leader, state_leader, and county_leader. 3. Create 'legislative_districts' table for mapping Captains to specific geographical areas. 4. Create 'mission_type_xp' lookup table with the 7 fixed types. 5. Create 'mission_ballots', 'ballot_endorsements', and 'ballot_commitments' tables. 6. Seed 'legislative_districts' with all 47 Maryland districts.",
        "testStrategy": "Verify schema updates in Supabase dashboard. Run SELECT queries to ensure 'mission_type_xp' contains all 7 types with correct XP values. Confirm RLS policies allow authenticated reading of district data.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Address Onboarding & Mapbox Geocoding Integration",
        "description": "Implement address entry screen in onboarding and integrate Mapbox Geocoding to auto-assign users to legislative districts.",
        "details": "1. Create AddressEntryScreen in Expo. 2. Fetch lat/lng using Mapbox Geocoding API: `https://api.mapbox.com/geocoding/v5/mapbox.places/${address}.json`. 3. Implement point-in-polygon logic or use a lookup table (maryland_district_lookup.json) to map lat/lng to a Maryland Legislative District. 4. Update the user's profile with geocoded data. 5. Provide a fallback manual dropdown if geocoding fails.",
        "testStrategy": "Enter a known Montgomery County address (e.g., in Bethesda) and verify the profile is updated with 'District 16'. Test the fallback dropdown for manual selection.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "AddressEntryScreen UI Development",
            "description": "Build the initial user interface for address input within the Expo onboarding flow.",
            "dependencies": [],
            "details": "Create a new screen called AddressEntryScreen. Include a Google Places style or standard text input for user addresses, a primary action button, and clear styling aligned with the project theme.",
            "status": "pending",
            "testStrategy": "Manually verify the UI renders correctly on both iOS and Android and that the input field correctly captures user text input."
          },
          {
            "id": 2,
            "title": "Mapbox Geocoding API Integration Service",
            "description": "Create a utility service to communicate with the Mapbox Geocoding API to retrieve coordinates.",
            "dependencies": [
              1
            ],
            "details": "Implement a fetch service to hit the endpoint https://api.mapbox.com/geocoding/v5/mapbox.places/${address}.json using a secure API key, and extract latitude and longitude from the response.",
            "status": "pending",
            "testStrategy": "Pass a known Bethesda address into the service and verify it returns the correct latitude and longitude coordinates for that location."
          },
          {
            "id": 3,
            "title": "Geo-spatial Matching Logic Implementation",
            "description": "Develop the logic to map geographic coordinates to specific Maryland Legislative Districts.",
            "dependencies": [
              2
            ],
            "details": "Implement logic using maryland_district_lookup.json or a point-in-polygon library to determine which district ID encompasses the lat/lng coordinates retrieved from Mapbox.",
            "status": "pending",
            "testStrategy": "Inject test coordinates for different Maryland regions and assert that the logic returns the expected legislative district ID for each."
          },
          {
            "id": 4,
            "title": "Profile Update Logic and Error Handling",
            "description": "Update the user's profile with the mapped district and manage API or lookup failures.",
            "dependencies": [
              3
            ],
            "details": "Write the function to update the 'user' object or database record with geocoded data. Include try-catch blocks to catch network errors or empty results from the Mapbox API.",
            "status": "pending",
            "testStrategy": "Submit a valid address and check the database/state for the updated district_id. Simulate a network failure to ensure the app doesn't crash."
          },
          {
            "id": 5,
            "title": "Manual Fallback Selection UI",
            "description": "Provide a manual dropdown selection for users if the automated geocoding process fails.",
            "dependencies": [
              1,
              4
            ],
            "details": "Create a conditional UI component that displays a dropdown picker populated with all valid Maryland Legislative Districts. This appears only if geocoding returns no results or fails.",
            "status": "pending",
            "testStrategy": "Enter a gibberish address to trigger the fallback and confirm that the manual dropdown appears and allows the user to continue the onboarding process."
          }
        ]
      },
      {
        "id": 13,
        "title": "Captain & Leadership Assignment UI",
        "description": "Build the 'Leadership' management interface for County, State, and National leaders to assign Captains to districts.",
        "details": "1. Create 'Leadership' tab in HQ screen, role-gated. 2. Implement drill-down navigation: State -> County -> District. 3. Create user search functionality within a specific district. 4. Implement 'Assign Captain' action which updates the 'legislative_districts.captain_id' and sets the target user's role to 'captain'. 5. Ensure validation: one captain per district.",
        "testStrategy": "Log in as a County Leader. Navigate to a district, search for a Warrior, and promote them. Verify the user's role changes in the database and the district shows the assigned Captain.",
        "priority": "medium",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Mission Creation Dropdown System",
        "description": "Implement the dynamic mission creation form for Captains and Leaders with auto-populated XP and scope levels.",
        "details": "1. Create a dynamic form in the HQ Missions tab. 2. Use a dropdown for the 7 mission types (RECRUIT_FRIENDS, SIGNAL_BOOST, etc.). 3. Implement conditional rendering for fields: target_url (Social), phone_email_script (Protest), raid_keyword (Raid). 4. Auto-populate XP and verification_method from 'mission_type_xp'. 5. Scope Level Logic: Captains are locked to 'District' scope; Leaders can select District, County, or State.",
        "testStrategy": "As a Captain, create a 'SIGNAL_BOOST' mission. Verify the XP is locked to 50 and the scope is auto-set to your district. Confirm the mission appears in the 'directives' table.",
        "priority": "high",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Social Media Link Opening & Frictionless Engagement",
        "description": "Update mission cards to support one-tap native app opening or in-app browser for social media missions.",
        "details": "1. Install 'expo-web-browser' and 'expo-linking'. 2. Create `openMissionLink` utility. 3. Update 'DirectiveCard' to show 'Open Link' button if 'target_url' exists. 4. Pseudo-code: `const canOpen = await Linking.canOpenURL(url); if (canOpen) { await Linking.openURL(url); } else { await WebBrowser.openBrowserAsync(url); }`. 5. Support deep links for Twitter, Reddit, and Instagram.",
        "testStrategy": "Tap 'Open Link' on a Twitter mission. Verify it opens the X app if installed, or the Expo web browser if not.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Enhanced AI Verification Logic (Gemini)",
        "description": "Extend the existing Gemini Edge Function to verify new mission types like Raid Keywords and PFP changes.",
        "details": "1. Update the Supabase Edge Function to accept 'mission_type' and 'verification_params' (e.g., raid_keyword). 2. Refine Gemini 1.5 Flash prompts to specifically look for engagement UI (likes/shares) for Signal Boosts or specific keywords in comments for Raids. 3. Implement logic to compare 'pfp_description' with uploaded screenshot for PFP missions.",
        "testStrategy": "Submit a screenshot for a 'RAID_COMMENTS' mission with the correct keyword. Verify Gemini returns a success status. Submit one without the keyword and verify rejection.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Edge Function Request Schema and Routing",
            "description": "Modify the Supabase Edge Function to accept and route the new mission_type and verification_params.",
            "dependencies": [],
            "details": "Update the TypeScript interfaces in the Supabase Edge Function to handle new types like RAID_COMMENTS and PFP_CHANGE. Implement logic to extract verification_params (e.g., raid_keyword) from the JSON payload.",
            "status": "pending",
            "testStrategy": "Unit test the Edge Function request parser with mock payloads for all mission types to ensure parameters are correctly identified."
          },
          {
            "id": 2,
            "title": "Refine Gemini System Prompts for Engagement Checks",
            "description": "Develop and refine the system prompts for Gemini 1.5 Flash to accurately identify likes, shares, and specific keywords.",
            "dependencies": [
              1
            ],
            "details": "Update the system instructions to specifically look for Twitter/X or Instagram UI elements like heart icons for likes and specific text strings within comments for Raid missions. Ensure the prompt returns a structured boolean response.",
            "status": "pending",
            "testStrategy": "Provide a set of benchmark screenshots to the Gemini model and verify the accuracy of its detection for likes and specific raid keywords."
          },
          {
            "id": 3,
            "title": "Implement PFP Visual Comparison Logic",
            "description": "Add logic to the Gemini prompt to compare a user's uploaded profile picture screenshot against a required description.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate logic that passes both the PFP screenshot and the target pfp_description to Gemini. The model must evaluate if the visual content of the image matches the textual description provided in the mission parameters.",
            "status": "pending",
            "testStrategy": "Submit a PFP screenshot that matches the description and one that does not; verify that the AI correctly approves the match and rejects the mismatch."
          },
          {
            "id": 4,
            "title": "Execute Comprehensive Integration Testing Suite",
            "description": "Build and run a suite of integration tests covering all new verification types within the updated Edge Function.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create automated test cases for RAID_COMMENTS (success/fail), SIGNAL_BOOST (verify likes), and PFP_CHANGE (visual match). Test edge cases such as low-quality screenshots and missing verification parameters.",
            "status": "pending",
            "testStrategy": "Run a batch script using curl or a testing framework to invoke the Supabase Edge Function and assert expected status codes and JSON responses."
          }
        ]
      },
      {
        "id": 17,
        "title": "Digital Ballot UI (Main Quest)",
        "description": "Create the 'Main Quest' screen to display a replica of the user's local ballot with endorsed candidates highlighted.",
        "details": "1. Create a new 'Main Quest' screen. 2. Fetch endorsements joined with 'mission_ballots' based on the user's 'legislative_district_id'. 3. Render candidates grouped by 'race_title'. 4. Apply Neon Green styling to candidates where 'is_endorsed' is true. 5. Implement 'Commit to Vote' toggle which inserts/deletes from 'ballot_commitments'.",
        "testStrategy": "Verify that a user in District 15 sees candidates for the District 15 State Senate race and that endorsed candidates are visually distinct.",
        "priority": "high",
        "dependencies": [
          11,
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Ballot Management Admin Tools",
        "description": "Implement admin screens for National and State leaders to create and manage digital ballots.",
        "details": "1. Create 'Ballot Manager' screen for high-level roles. 2. Implement forms to: Create a Ballot (State/Election Date), Add Race (Title/Order), and Add Candidate (Name/Endorsement status). 3. Add a 'Preview' mode to view the ballot exactly as a Warrior would. 4. Implement 'Publish' toggle to make ballots visible to users.",
        "testStrategy": "Create a test ballot for a specific district. Log in as a Warrior in that district and confirm the ballot appears correctly in the 'Main Quest' tab.",
        "priority": "medium",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Notification Discipline & Retention Strategy",
        "description": "Implement the notification opt-in UI and scoped messaging logic to ensure high-value engagement.",
        "details": "1. Add a 'Notification Warning' screen to onboarding: 'Disabling notifications means missing critical election night intel.' 2. Create notification scope logic: query for users where `user.district_id === mission.target_district_id` OR `user.county === mission.target_county`, etc. 3. Integrate existing push provider to trigger alerts on mission creation.",
        "testStrategy": "Create a District-level mission as a Captain. Verify a push notification is sent only to users in that specific district. Check that the notification text matches the 'Action-Oriented' guidelines in the PRD.",
        "priority": "medium",
        "dependencies": [
          12,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Multi-State Scalability & Final Integration",
        "description": "Prepare architecture for expansion to Florida and South Carolina and conduct end-to-end system testing.",
        "details": "1. Verify geocoding logic works for non-Maryland addresses. 2. Add 'state' filter to all mission and ballot queries. 3. Conduct E2E test: User signs up with a FL address -> Assigned to FL District -> Sees FL missions and FL ballot. 4. Final performance check for 10k+ concurrent user data structures.",
        "testStrategy": "Simulate a user registration from Miami, FL. Verify 'leadership_state' is set to Florida and no Maryland missions are visible in the feed.",
        "priority": "low",
        "dependencies": [
          12,
          14,
          17,
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Multi-state Schema Audit and Filtering Updates",
            "description": "Audit the existing database schema and update all mission and ballot queries to include state-level filtering.",
            "dependencies": [],
            "details": "Review the Supabase schema to ensure 'state' columns exist across all relevant tables (missions, ballots, profiles). Update Row Level Security (RLS) policies and frontend API calls to include a 'state' filter parameter to prevent cross-state data leakage.",
            "status": "pending",
            "testStrategy": "Run SQL queries against the missions table using 'FL' as a filter and verify that no 'MD' records are returned in the result set."
          },
          {
            "id": 2,
            "title": "E2E Lifecycle Testing for Multi-State Users",
            "description": "Conduct end-to-end testing of the full user lifecycle for non-Maryland addresses from registration to content delivery.",
            "dependencies": [
              1
            ],
            "details": "Simulate a user registration flow using a Florida address. Verify that Mapbox Geocoding correctly identifies the state, the profile is updated with the FL state code, and the feed displays only Florida-specific missions and legislative data.",
            "status": "pending",
            "testStrategy": "Manual walkthrough of the onboarding process using a Miami address; verify the final dashboard content matches the user's geocoded state."
          },
          {
            "id": 3,
            "title": "High-Concurrency Performance Profiling",
            "description": "Evaluate and optimize system performance for 10,000+ concurrent users across multiple states.",
            "dependencies": [
              1,
              2
            ],
            "details": "Utilize load testing tools to simulate 10,000 concurrent connections. Analyze database execution plans for mission queries and profile updates. Optimize indexes on 'state' and 'district' columns to ensure sub-second response times under load.",
            "status": "pending",
            "testStrategy": "Execute a k6 load test script simulating 10k users and monitor the Supabase dashboard for API latency and CPU spikes."
          },
          {
            "id": 4,
            "title": "Final Production Environment Configuration",
            "description": "Finalize production settings, environment variables, and deployment pipelines for the multi-state rollout.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Configure production-ready environment variables for Mapbox and Supabase. Review and harden security headers. Ensure the CI/CD pipeline is configured for blue-green deployment to minimize downtime during the state-wide expansion.",
            "status": "pending",
            "testStrategy": "Validate all environment secrets are present in the production container and perform a smoke test on the production URL."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2026-01-31T02:18:39.293Z",
      "updated": "2026-02-04T04:19:17.551Z",
      "description": "Tasks for master context"
    }
  }
}